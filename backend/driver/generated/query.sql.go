// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db_driver

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteTodo = `-- name: DeleteTodo :exec
WITH deleted_todos AS (
  DELETE FROM task_canvas.user_todo
  WHERE todo_id = $1::uuid
  AND user_id = $2::uuid
  RETURNING todo_id
)
DELETE FROM task_canvas.todo
WHERE id IN (SELECT todo_id FROM deleted_todos)
`

type DeleteTodoParams struct {
	TodoID uuid.UUID `json:"todo_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteTodo(ctx context.Context, arg DeleteTodoParams) error {
	_, err := q.db.Exec(ctx, deleteTodo, arg.TodoID, arg.UserID)
	return err
}

const findTodo = `-- name: FindTodo :many
SELECT
  task_canvas.todo.id AS todo_id,
  task_canvas.todo.content AS content,
  task_canvas.todo.completed AS completed,
  task_canvas.todo.created_at AS created_at,
  task_canvas.user.id AS user_id,
  task_canvas.user.email AS email,
  task_canvas.user.password_hash AS password_hash
FROM
  task_canvas.todo
INNER JOIN
  task_canvas.user_todo ON task_canvas.todo.id = task_canvas.user_todo.todo_id
INNER JOIN
  task_canvas.user ON task_canvas.user_todo.user_id = task_canvas.user.id
WHERE
  task_canvas.user.id = $1::uuid
`

type FindTodoRow struct {
	TodoID       uuid.UUID        `json:"todo_id"`
	Content      string           `json:"content"`
	Completed    bool             `json:"completed"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UserID       uuid.UUID        `json:"user_id"`
	Email        string           `json:"email"`
	PasswordHash string           `json:"password_hash"`
}

func (q *Queries) FindTodo(ctx context.Context, userID uuid.UUID) ([]FindTodoRow, error) {
	rows, err := q.db.Query(ctx, findTodo, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTodoRow
	for rows.Next() {
		var i FindTodoRow
		if err := rows.Scan(
			&i.TodoID,
			&i.Content,
			&i.Completed,
			&i.CreatedAt,
			&i.UserID,
			&i.Email,
			&i.PasswordHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByEmail = `-- name: FindUserByEmail :many
SELECT
  id,
  email,
  password_hash
FROM
  task_canvas.user
WHERE
  email = $1::text
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) ([]TaskCanvasUser, error) {
	rows, err := q.db.Query(ctx, findUserByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskCanvasUser
	for rows.Next() {
		var i TaskCanvasUser
		if err := rows.Scan(&i.ID, &i.Email, &i.PasswordHash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserById = `-- name: FindUserById :one
SELECT
  id,
  email,
  password_hash
FROM
  task_canvas.user
WHERE
  id = $1::uuid
`

func (q *Queries) FindUserById(ctx context.Context, id uuid.UUID) (TaskCanvasUser, error) {
	row := q.db.QueryRow(ctx, findUserById, id)
	var i TaskCanvasUser
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const insertTodo = `-- name: InsertTodo :exec
INSERT INTO task_canvas.todo (
  id,
  content,
  completed
)
VALUES (
  $1::uuid,
  $2::text,
  $3::boolean
)
`

type InsertTodoParams struct {
	ID        uuid.UUID `json:"id"`
	Content   string    `json:"content"`
	Completed bool      `json:"completed"`
}

func (q *Queries) InsertTodo(ctx context.Context, arg InsertTodoParams) error {
	_, err := q.db.Exec(ctx, insertTodo, arg.ID, arg.Content, arg.Completed)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO task_canvas.user (
  id,
  email,
  password_hash
) VALUES (
  $1::uuid,
  $2::text,
  $3::text
)
`

type InsertUserParams struct {
	ID           uuid.UUID `json:"id"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser, arg.ID, arg.Email, arg.PasswordHash)
	return err
}

const insertUserTodo = `-- name: InsertUserTodo :exec
INSERT INTO task_canvas.user_todo (
  user_id,
  todo_id
)
VALUES (
  $1::uuid,
  $2::uuid
)
`

type InsertUserTodoParams struct {
	UserID uuid.UUID `json:"user_id"`
	TodoID uuid.UUID `json:"todo_id"`
}

func (q *Queries) InsertUserTodo(ctx context.Context, arg InsertUserTodoParams) error {
	_, err := q.db.Exec(ctx, insertUserTodo, arg.UserID, arg.TodoID)
	return err
}

const updateTodo = `-- name: UpdateTodo :exec
UPDATE task_canvas.todo
SET
  content = $1::text,
  completed = $2::boolean
FROM task_canvas.user_todo
WHERE
  task_canvas.todo.id = task_canvas.user_todo.todo_id
  AND task_canvas.todo.id = $3::uuid
  AND task_canvas.user_todo.user_id = $4::uuid
`

type UpdateTodoParams struct {
	Content   string    `json:"content"`
	Completed bool      `json:"completed"`
	TodoID    uuid.UUID `json:"todo_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateTodo(ctx context.Context, arg UpdateTodoParams) error {
	_, err := q.db.Exec(ctx, updateTodo,
		arg.Content,
		arg.Completed,
		arg.TodoID,
		arg.UserID,
	)
	return err
}
